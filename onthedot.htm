<!DOCTYPE HTML>
<html>
  <head>
    <script type="text/javascript" src = "js/game.js"></script>
    <script type="text/javascript" src = "js/math2D.js"></script>
    <script type="text/javascript" src = "js/drawing.js"></script>
    <script type="text/javascript" src = "js/colors.js"></script>
    <script type="text/javascript" src = "js/utility.js"></script>
    <script type="text/javascript" src = "js/mouse.js"></script>
    <script type="text/javascript" src = "js/keyboard.js"></script>
    <script type="text/javascript" src = "js/gameobject.js"></script>
    <script type="text/javascript" src = "js/field.js"></script>
    <title>New Game</title>
    <style>
      body {
        background-color: #0F0404;
      }
      canvas {
        cursor: none;
      }
    </style>
  </head>
  
  <body>
    <center><canvas id="game_canvas" style="background-color:'#FEE882'"></canvas></center>
  </body>
  
  <script type="text/javascript">
    // Dimensions
    var toolbox_width = 150;
    var toolbox_item_size = xy(100, 100);
    var toolbox_pad = 30;
    var point_radius = 20;
    var ball_radius = 15;
    var end_point_tolerance = 5;
    var wall_size = xy(80, 5);
    var wall_tolerance = 3;
    var attractor_radius = 10;
    
    // Inputs
    var inputs = {
      start_run: "SPACE",
      halt_run: "SPACE",
      enter_design_mode: "ENTER"
    }
    
    // Colors
    var colors = {
      blackish: "#0F0404",
      bg: "#FEE882",
      toolbox: "#B57F35",
      point: "#CA7316",
      ball: "#442415"
    }
    
    // ========================================= The game
    var game = new Game({bg_color: colors.bg});
    game.setTitle("On The Dot");
    game.setSize(xy(800, 600));
    window.onload = function() {
      game.start();
    }
    // Modes can be "design", "running", or "score"
    game.mode = "design";
    
    console.log("Press space to start the ball running.");
    
     // HERE LIE MISCELLANEOUS DEBUG STATMENETS
    game.tickActions.push(function() {
      
    });
    
    // Detect changes in game state
    game.tickActions.push(function() {
      // Start running the ball/timer
      if (game.mode == "design" && game.isKeyPressed(inputs.start_run)) {
        timer.start();
        ball.start();
        game.mode = "running";
      }
      // Player halts the run
      else if (game.mode == "running" && game.isKeyPressed(inputs.halt_run)) {
        ball.stop();
        timer.stop();
        ball.reset();
        game.mode = "design";
      }
      // The ball reaches the end
      else if (game.mode == "running" && distance(ball.pos, end_point.pos) < end_point_tolerance) {
        console.log("The ball has arrived!");
        ball.stop();
        timer.stop();
        this.score();
        console.log("Press enter to re-design");
        game.mode = "score";
      }
      // Player goes back to design mode
      else if (game.mode == "score" && game.isKeyPressed(inputs.enter_design_mode)) {
        ball.reset();
        game.mode = "design";
      }
      
      // TODO: player can halt or pause the running
    });
    
    // Show the player the score
    game.score = function() {
      console.log("Time taken: " + timer.result + " seconds." );
      console.log("That is only " + Math.abs(timer.result - 10) + " seconds away from 10 seconds!");
    }
    
    // ========================================= Images
    var img_cursor = loadImage(game.ctx, "images/cursor.png");
    
    
    // ========================================= The timer
    var timer = new GameObject(game);
    timer.t0 = null;
    timer.result = 0;
    timer.start = function() {
      this.t0 = now();
      this.result = 0;
    }
    timer.stop = function() {
      this.result = this.getTime();
      this.t0 = null;
    }
    timer.getTime = function() {
      if (game.mode != "running") return this.result;
      return getTimeSince(this.t0)/1000;
    }
    
    // ========================================= The start and end points
    var start_point = new GameObject(game);
    start_point.pos = xy(250, 100);
    start_point.draw = function() {
      this.ctx.save();
      this.ctx.globalAlpha = 1;
      circle(this.ctx, this.pos, point_radius, colors.point);
      this.ctx.globalAlpha = 1;
      emptyCircle(this.ctx, this.pos, point_radius - 5, colors.point);
      emptyCircle(this.ctx, this.pos, point_radius - 10, colors.point);
      emptyCircle(this.ctx, this.pos, point_radius - 15, colors.point);
      this.ctx.restore();
    }
    
    var end_point = new GameObject(game);
    end_point.pos = xy(700, 500);
    end_point.draw = start_point.draw;
    
    // ========================================= The ball
    var ball = new GameObject(game);
    ball.pos = start_point.pos.copy();
    actuate(ball);
    //navigate(ball, keydirs_lrud, 3); // temporary
    ball.freeze();
    ball.imprints = [];
    ball.draw = function() {
      circle(this.ctx, this.pos, ball_radius, colors.ball);
      if (game.mode != "design") text(this.ctx, Math.floor(timer.getTime()).toString(), yshift(this.pos, -2), 'centered', 'white');
      if (game.mode != "design") {
        this.ctx.save();
        this.ctx.globalAlpha = 0.5;
        for (var i = 0; i < this.imprints.length; i++) {
          circle(this.ctx, this.imprints[i], ball_radius, colors.ball);
          text(this.ctx,(i+1).toString(), yshift(this.imprints[i], -2), 'centered', 'black');
        }
        this.ctx.restore();
      }
    }
    ball.start = function() {
      this.velocity = xy(0, 1);
      this.unfreeze();
      setTimeout(function() { ball.imprint(); }, 1000);
    }
    ball.stop = function() {
      this.velocity = xy(0, 0);
      this.unfreeze();
    }
    ball.reset = function() {
      this.pos = start_point.pos.copy();
      this.imprints = [];
    }
    ball.imprint = function() {
      if (game.mode != "running") return;
      this.imprints.push(this.pos.copy());
      setTimeout(function() { ball.imprint(); }, 1000);
    }
    // Movement effects
    ball.reverse = function() {
      this.velocity.neg();
    }
    
    // ========================================= Toolbox
    var toolbox = new GameObject(game);
    toolbox.drawActions.push(function() {
      rect(this.ctx, xy(-1, -1), xy(toolbox_width, game.size.y), colors.toolbox);
      text(this.ctx, "TOOLBOX", xy(toolbox_width / 2, toolbox_pad), "centered", colors.blackish);
    });
    toolbox.getItemPos = function(index) {;
      return xy(toolbox_width / 2 - toolbox_item_size.x / 2, 
                toolbox_pad * (2 + index) + toolbox_item_size.y * (index));
    }
    toolbox.drawItemBox = function(index) {
      var center = this.getItemPos(index);
      this.ctx.save();
      this.ctx.globalAlpha = 0.5;
      rect_rounded(this.ctx, center, add(center, toolbox_item_size), 10, colors.blackish);
      this.ctx.restore();
      return center;
    }
    itemBoxContains = function(pos, index) {
      return isInArea(pos, toolbox.getItemPos(index), toolbox_item_size);
    }
    
    // Individual icons
    configToolboxIcon = function(tool, index) {
      tool.icon.parent = tool;
      tool.icon.index = index;
      tool.icon.drawActions.push(function() { toolbox.drawItemBox(this.index); });
      tool.icon.drawActions.push(tool.draw);
      tool.icon.pos = add(toolbox.getItemPos(tool.icon.index), scale(toolbox_item_size, 0.5));
      tool.icon.contains = function(pos) { return itemBoxContains(pos, this.index); } 
      tool.icon.onmousedown = function() { player.current_tool = this.parent; }
    }
    
    // Tools
    var tools = {};
    
    // ========================================= Walls 
    /* TODO:
      - Make an input method for rotated walls
      - When checking for collision, account for wall rotation
      - Actually make the ball bounce properly.
    */
    
    tools.wall = {
      icon: new GameObject(game),
      draw: function(pos, rotation) {
        if (pos == null) pos = this.pos;
        if (rotation == null) rotation = 0;
        game.ctx.save();
        game.ctx.translate(pos.x, pos.y);
        game.ctx.rotate(radians(rotation));
        game.ctx.translate(-pos.x, -pos.y);
        rect(game.ctx, subtract(pos, scale(wall_size, 0.5)), add(pos, scale(wall_size, 0.5)), colors.blackish);
        game.ctx.restore();
      },
      instances: [],
      make: function(pos, rotation) {
        var wall = new GameObject(game);
        wall.parent = this;
        wall.pos = pos;
        wall.rotation = rotation;
        wall.drawActions.push(function() { this.parent.draw(this.pos, this.rotation); });
        wall.tickActions.push(function() {
          if (Math.abs(ball.pos.y - this.pos.y) < ball_radius + wall_tolerance) ball.reverse();
          // TODO TODO TODO: redo and account for rotation.
        });
        this.instances.push(wall);
      }
    }
    configToolboxIcon(tools.wall, 0);
    
    // ========================================= Player (specifies which tool to use, etc)
    /* Notes:
       - If you want to make the current tool stay persistent over multiple runs, change line %%1
    
    */
    
    var player = new GameObject(game);
    player.current_tool = null;
    player.draw = function() {
      if (game.mode != "design") { this.current_tool = null; return; } //%%1
      if (this.current_tool == null) {
        this.ctx.drawImage(img_cursor, mouse.pos.x - img_cursor.width/2, mouse.pos.y - img_cursor.height/2);
      }
      else {
        this.current_tool.draw(mouse.pos);
      }
    }
    player.contains = function(pos) { // this indicates everywhere that the player can place a tool
      return isBetweenCoords(pos, xy(toolbox_width, 0), game.size);
    }
    player.onclick = function() {
      if (game.mode != "design") return;
      if (this.current_tool == null) return;
      this.current_tool.make(mouse.pos);
    }
    
  </script>
</html>