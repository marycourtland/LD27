<!DOCTYPE HTML>
<html>
  <head>
    <script type="text/javascript" src = "js/game.js"></script>
    <script type="text/javascript" src = "js/math2D.js"></script>
    <script type="text/javascript" src = "js/drawing.js"></script>
    <script type="text/javascript" src = "js/colors.js"></script>
    <script type="text/javascript" src = "js/utility.js"></script>
    <script type="text/javascript" src = "js/mouse.js"></script>
    <script type="text/javascript" src = "js/keyboard.js"></script>
    <script type="text/javascript" src = "js/gameobject.js"></script>
    <script type="text/javascript" src = "js/field.js"></script>
    <title>On the Dot</title>
    <style>
      body {
        background-color: #0F0404;
      }
      canvas {
        cursor: none;
        background-color:#FEE882
      }
    </style>
  </head>
  
  <body>
    <center><canvas id="game_canvas"></canvas></center>
  </body>
  
  <script type="text/javascript">
    // Boolean options
    var leave_ball_imprints = true;
    var keep_tool_over_runs = true;
    
    // Dimensions
    var start_pos = xy(250, 150);
    var end_pos = xy(700, 450);
    var toolbox_width = 150;
    var toolbox_item_size = xy(100, 100);
    var toolbox_pad = 30;
    var point_radius = 20;
    var ball_radius = 15;
    var ball_start_velocity = xy(0, 1.5);
    var end_point_tolerance = 5;
    var wall_size = xy(80, 5);
    var wall_tolerance = 0;
    var attractor_radius = 10;
    
    var default_font = {size: 16, type: 'Arial', italic: false};
    
    var goal_text = "Your goal: guide the ball to the other point, in as close to 10 seconds as possible!";
    var instructions_text = "Use a tool to change the ball's course. Press space to start a run.";
    
    // Inputs
    var inputs = {
      start_run: "SPACE",
      halt_run: "SPACE",
      enter_design_mode: "ENTER",
      rotate_wall_cw: "D",
      rotate_wall_ccw: "A",
    }
    
    // Colors
    var colors = {
      blackish: "#0F0404",
      bg: "#FEE882",
      toolbox: "#B57F35",
      point: "#CA7316",
      ball: "#442415"
    }
    
    // ========================================= The game
    var game = new Game({bg_color: colors.bg});
    game.setTitle("On The Dot");
    game.setSize(xy(800, 600));
    game.setFont(default_font);
    window.onload = function() {
      game.start();
    }
    // Modes can be "design", "running", or "score"
    game.mode = "design";
    
    console.log("Press space to start the ball running.");
    
     // HERE LIE MISCELLANEOUS DEBUG STATEMENTS. RIP BUGS
    game.tickActions.push(function() {
      //scale(ball.velocity, 100).arrowOn(this.ctx, xy(500, 200)); // Show ball velocity
    });
    
    // Detect changes in game state
    game.tickActions.push(function() {
      
      // Start running the ball/timer
      if (game.mode == "design" && game.isKeyPressed(inputs.start_run)) {
        info.text = "Press space to interrupt the run";
        info.text2 = "";
        timer.start();
        ball.start();
        game.mode = "running";
      }
      
      // Player halts the run
      else if (game.mode == "running" && game.isKeyPressed(inputs.halt_run)) {
        ball.stop();
        timer.stop();
        ball.reset();
        game.mode = "design";
        info.text = instructions_text;
        info.text2 = goal_text;
      }
      
      // The ball reaches the end
      else if (game.mode == "running" && distance(ball.pos, end_point.pos) < end_point_tolerance) {
        console.log("The ball has arrived!");
        ball.stop();
        timer.stop();
        this.score();
        
        info.text = "Time: " + round(timer.result, 1) + " seconds. Press enter try again!";
        game.mode = "score";
      }
      
      // Player goes back to design mode
      else if (game.mode == "score" && game.isKeyPressed(inputs.enter_design_mode)) {
        ball.reset();
        game.mode = "design";
        info.text = instructions_text;
        info.text2 = goal_text;
      }
      
      // TODO: player can halt or pause the running
    });
    
    // Show the player the score
    game.score = function() {
      console.log("Time taken: " + timer.result + " seconds." );
      console.log("That is only " + Math.abs(timer.result - 10) + " seconds away from 10 seconds!");
    }
    
    // ========================================= Images
    var img_cursor = loadImage(game.ctx, "images/cursor.png");
    
    
    // ========================================= The timer
    var timer = new GameObject(game);
    timer.t0 = null;
    timer.result = 0;
    timer.start = function() {
      this.t0 = now();
      this.result = 0;
    }
    timer.stop = function() {
      this.result = this.getTime();
      this.t0 = null;
    }
    timer.getTime = function() {
      if (game.mode != "running") return this.result;
      return getTimeSince(this.t0)/1000;
    }
    
    // ========================================= The start and end points
    var start_point = new GameObject(game);
    start_point.pos = start_pos;
    start_point.draw = function() {
      this.ctx.save();
      this.ctx.globalAlpha = 1;
      circle(this.ctx, this.pos, point_radius, colors.point);
      this.ctx.globalAlpha = 1;
      emptyCircle(this.ctx, this.pos, point_radius - 5, colors.point);
      emptyCircle(this.ctx, this.pos, point_radius - 10, colors.point);
      emptyCircle(this.ctx, this.pos, point_radius - 15, colors.point);
      this.ctx.restore();
    }
    
    var end_point = new GameObject(game);
    end_point.pos = end_pos;
    end_point.draw = start_point.draw;
    
    // ========================================= The ball
    var ball = new GameObject(game);
    ball.pos = start_point.pos.copy();
    actuate(ball);
    ball.tickActions.push(function() { game.mode == 'running'? this.unfreeze() : this.freeze(); });
    navigate(ball, keydirs_lrud, 3); // temporary
    ball.freeze();
    ball.imprints = [];
    ball.draw = function() {
      circle(this.ctx, this.pos, ball_radius, colors.ball);
      if (game.mode != "design") text(this.ctx, Math.floor(timer.getTime()).toString(), yshift(this.pos, -2), 'centered', 'white');
      if (game.mode != "design") {
        this.ctx.save();
        this.ctx.globalAlpha = 0.5;
        for (var i = 0; i < this.imprints.length; i++) {
          circle(this.ctx, this.imprints[i], ball_radius, colors.ball);
          text(this.ctx,(i+1).toString(), yshift(this.imprints[i], -2), 'centered', 'black');
        }
        this.ctx.restore();
      }
    }
    ball.start = function() {
      this.velocity = ball_start_velocity.copy();
      this.unfreeze();
      if (leave_ball_imprints) setTimeout(function() { ball.imprint(); }, 1000);
    }
    ball.stop = function() {
      this.velocity = xy(0, 0);
      this.freeze();
    }
    ball.reset = function() {
      this.pos = start_point.pos.copy();
      this.imprints = [];
      this.freeze();
    }
    ball.imprint = function() {
      if (game.mode != "running") return;
      this.imprints.push(this.pos.copy());
      setTimeout(function() { ball.imprint(); }, 1000);
    }
    // Movement effects
    ball.reverse = function() {
      this.velocity.neg();
    }
    
    // ========================================= Toolbox
    var toolbox = new GameObject(game);
    toolbox.drawActions.push(function() {
      rect(this.ctx, xy(-1, -1), xy(toolbox_width, game.size.y), colors.toolbox);
      text(this.ctx, "TOOLBOX", xy(toolbox_width / 2, toolbox_pad), "centered", colors.blackish);
    });
    toolbox.getItemPos = function(index) {;
      return xy(toolbox_width / 2 - toolbox_item_size.x / 2, 
                toolbox_pad * (2 + index) + toolbox_item_size.y * (index));
    }
    toolbox.drawItemBox = function(index) {
      var center = this.getItemPos(index);
      this.ctx.save();
      this.ctx.globalAlpha = 0.5;
      rect_rounded(this.ctx, center, add(center, toolbox_item_size), 10, colors.blackish);
      this.ctx.restore();
      return center;
    }
    itemBoxContains = function(pos, index) {
      return isInArea(pos, toolbox.getItemPos(index), toolbox_item_size);
    }
    
    // Individual icons
    configToolboxIcon = function(tool, index) {
      tool.icon.parent = tool;
      tool.icon.index = index;
      tool.icon.drawActions.push(function() { toolbox.drawItemBox(this.index); });
      tool.icon.drawActions.push(tool.draw);
      tool.icon.pos = add(toolbox.getItemPos(tool.icon.index), scale(toolbox_item_size, 0.5));
      tool.icon.contains = function(pos) { return itemBoxContains(pos, this.index); } 
      tool.icon.onmousedown = function() { player.setTool(this.parent); }
    }
    
    // Tools
    var tools = {};
    
    // ========================================= Walls 
    /* TODO:
      - Make an input method for rotated walls
      - When checking for collision, account for wall rotation
      - Actually make the ball bounce properly.
    */
    
    tools.wall = {
      info: "The wall: causes the ball to bounce. Use A and D to turn it, and click to place.",
      icon: new GameObject(game),
      draw: function(pos, rotation) {
        if (pos == null) pos = this.pos;
        if (rotation == null) rotation = tools.wall.input_params.rotation;
        game.ctx.save();
        game.ctx.translate(pos.x, pos.y);
        game.ctx.rotate(radians(rotation));
        game.ctx.translate(-pos.x, -pos.y);
        rect(game.ctx, subtract(pos, scale(wall_size, 0.5)), add(pos, scale(wall_size, 0.5)), colors.blackish);
        game.ctx.restore();
      },
      instances: [],
      make: function(pos) {
        var wall = new GameObject(game);
        wall.parent = this;
        wall.pos = pos;
        wall.rotation = this.input_params.rotation;
        console.log("rotation: " + wall.rotation);
        wall.has_interacted = false; // This will ensure that only 1 bounce is triggered when the ball bounces
        wall.vector = rth(1, radians(wall.rotation));
        wall.isBallTouching = function() {
          var ballToThis = subtract(this.pos, ball.pos);
          var d = Math.abs(projection(ballToThis, radians(this.rotation + 90)).r);
          var l = Math.abs(projection(ballToThis, radians(this.rotation)).r);
          return d < (wall_size.y/2 + ball_radius) && l < wall_size.x/2;
          //return Math.abs(ball.pos.y - this.pos.y) < ball_radius + wall_tolerance;
        }
        wall.drawActions.push(function() { this.parent.draw(this.pos, this.rotation); });
        wall.tickActions.push(function() {
          if (this.isBallTouching()) {
            if (!this.has_interacted) ball.velocity.reflect(this.vector);
            this.has_interacted = true;
          }
          else this.has_interacted = false;
          // TODO TODO TODO: redo and account for rotation.
        });
        this.instances.push(wall);
      },
      input_params: { rotation: 0 },
      
      //not finished yet
      param_input_checks: [ 
        function() {
          if (game.isKeyDown(inputs.rotate_wall_cw)) pass;
        }
      ]
    }
    configToolboxIcon(tools.wall, 0);
    
    // ========================================= Attractors
    
    tools.attractor = {
      info: "The attractor: pulls the ball towards it. Click to place.",
      icon: new GameObject(game),
      draw: function(pos) {
        if (pos == null) pos = this.pos;
        circle(game.ctx, pos, attractor_radius, colors.blackish);
      },
      instances: [],
      make: function(pos) {
        var attractor = new GameObject(game);
        attractor.parent = this;
        attractor.pos = pos;
        attractor.field = field_inverse_square(pos.copy(), {scale: 1000});
        ball.obey('temp', attractor.field);
        attractor.drawActions.push(function() { this.parent.draw(this.pos); });
        attractor.tickActions.push(function() {
          // TODO
        });
        this.instances.push(attractor);
      }
    }
    configToolboxIcon(tools.attractor, 1);
    
    
    // ========================================= Player (specifies which tool to use, etc)
    /* Notes:
    */
    
    var player = new GameObject(game);
    player.current_tool = null;
    player.draw = function() {
      if (game.mode != "design") { if (keep_tool_over_runs) this.current_tool = null; return; }
      if (this.current_tool == null) {
        this.ctx.drawImage(img_cursor, mouse.pos.x - img_cursor.width/2, mouse.pos.y - img_cursor.height/2);
      }
      else {
        this.current_tool.draw(mouse.pos);
      }
    }
    player.contains = function(pos) { // this indicates everywhere that the player can place a tool
      return isBetweenCoords(pos, xy(toolbox_width, 0), game.size);
    }
    player.setTool = function(tool) {
      this.current_tool = tool;
      info.text = tool.info;
    }
    player.onclick = function() {
      if (game.mode != "design") return;
      if (this.current_tool == null) return;
      this.current_tool.make(mouse.pos);
    }
    // Check for inputs that change the tool params
    player.tickActions.push(function() {
      if (this.current_tool == tools.wall) {
        if (game.isKeyDown(inputs.rotate_wall_cw)) {
          tools.wall.input_params.rotation += 1;
        }
        else if (game.isKeyDown(inputs.rotate_wall_ccw)) {
          tools.wall.input_params.rotation -= 1;
        }
      }
    });
    
    
    // ========================================= Info line
    
    var info = new GameObject(game);
    info.pos = xy(toolbox_width + (game.size.x - toolbox_width) / 2, toolbox_pad);
    info.pos2 = xy(toolbox_width + (game.size.x - toolbox_width) / 2, game.size.y - toolbox_pad);
    info.text = instructions_text;
    info.text2 = goal_text;
    info.font = {size: 16, type: 'Arial', italic: true};
    info.draw = function() {
      game.setFont(this.font);
      text(this.ctx, this.text, this.pos, "centered", colors.blackish);
      text(this.ctx, this.text2, this.pos2, "centered", colors.blackish);
      game.setFont(default_font);
    }
    
    
  </script>
</html>