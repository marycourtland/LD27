<!DOCTYPE HTML>
<html>
  <head>
    <script type="text/javascript" src = "js/game.js"></script>
    <script type="text/javascript" src = "js/math2D.js"></script>
    <script type="text/javascript" src = "js/drawing.js"></script>
    <script type="text/javascript" src = "js/colors.js"></script>
    <script type="text/javascript" src = "js/utility.js"></script>
    <script type="text/javascript" src = "js/mouse.js"></script>
    <script type="text/javascript" src = "js/keyboard.js"></script>
    <script type="text/javascript" src = "js/gameobject.js"></script>
    <script type="text/javascript" src = "js/field.js"></script>
    <title>On the Dot</title>
    <style>
      body {
        background-color: #0F0404;
      }
      canvas {
        position: absolute;
        top: 50;
        left: 50;
      }
      canvas#game_canvas {
        z-index: 2;
      }
      canvas#imprint_canvas {
        background-color: #FEE882;
        z-index: 1;
      }
    </style>
  </head>
  
  <body>
    <canvas id="game_canvas"></canvas>
    <canvas id="imprint_canvas"></canvas>
  </body>
  
  <script type="text/javascript">
    // Boolean options
    var leave_ball_imprints = false;
    var keep_tool_over_runs = true; // removed
    
    // Dimensions
    var level_text_height = 150;
    var start_pos = xy(100, 300);
    var end_pos = xy(700, 300);
    var text_pad = 30;
    var point_radius = 20;
    var ball_radius = 15;
    var ball_imprint_radius = 4;
    var ball_start_velocity = xy(0, 0);
    var ball_speed = 2;
    var end_point_tolerance = 5;
    var wall_size = xy(80, 5);
    var wall_tolerance = 0;
    var attractor_radius = 10;
    var timer_pos = xy(670, 50);
    var timer_size = xy(50, 30);
    var timer_pad = xy(10, 5);
    var swamp_speed_reduction = 0.28;
    
    var default_font = {size: 16, type: 'Arial', italic: false};
    var level_font = {size: 12, type: 'Arial', italic: true};
    var huge_font = {size: 72, type: 'Arial', italic: false};
    
    var goal_text = "Your goal: guide the ball to the other point, in as close to 10 seconds as possible!";
    var instructions_text = "Press space to start a run, then use the arrow keys to guide the ball.";
    var cancel_text = "Press space to cancel the run"
    
    // Inputs
    var inputs = {
      start_run: "SPACE",
      halt_run: "SPACE",
      enter_design_mode: "SPACE",
      next_level: "ENTER",
      rotate_wall_cw: "D",
      rotate_wall_ccw: "A",
    }
    
    // Colors
    var colors = {
      blackish: "#0F0404",
      bg: "#FEE882",
      timer: "#B57F35",
      level_text: "#B57F35",
      point: "#CA7316",
      ball: "#442415",
      ball2: "#B57F35",
      ball_faded: "#A1864B",
      swamp: "#6B5B0E",
    }
    
    // ========================================= The game
    var game = new Game({bg_color: colors.bg});
    game.setTitle("On The Dot");
    game.setSize(xy(800, 600));
    game.setFont(default_font);
    window.onload = function() {
      game.start();
    }
    // Modes can be "design", "running", or "score"
    game.mode = "design";
    game.imprint_ctx = document.getElementById("imprint_canvas").getContext("2d");
    game.setSize(game.size, game.imprint_ctx);
    
     // HERE LIE MISCELLANEOUS DEBUG STATEMENTS. RIP BUGS
    game.finalActions.push(function() {
      //scale(ball.velocity, 100).arrowOn(this.ctx, xy(500, 200)); // Show ball velocity
    });
    
    // Detect changes in game mode
    game.tickActions.push(function() {
      // Start running the ball/timer
      if (game.mode == "design" && game.isKeyPressed(inputs.start_run)) this.enterRunningMode();
      
      // Player halts the run
      else if (game.mode == "running" && game.isKeyPressed(inputs.halt_run)) { this.endRunningMode(); this.enterDesignMode(); }
      
      // The ball reaches the end
      else if (game.mode == "running" && distance(ball.pos, end_point.pos) < end_point_tolerance) { this.endRunningMode(); this.enterScoreMode(); }
      
      // Player tries again
      else if (game.mode == "score" && game.isKeyPressed(inputs.start_run)) this.enterRunningMode();
      
      // Player goes to next level
      else if (game.mode == "score" && game.isKeyPressed(inputs.next_level)) { this.doNextLevel(); this.enterDesignMode(); }
    });
    
    // Change mode
    game.enterDesignMode = function() {
      clear(game.imprint_ctx);
      ball.reset();
      game.mode = "design";
    }
    game.enterRunningMode = function() {
      clear(game.imprint_ctx);
      ball.reset();
      timer.start();
      ball.start();
      game.mode = "running";
    }
    game.endRunningMode = function() {
      ball.stop();
      timer.stop();
    }
    game.enterScoreMode = function() {
        this.score();
        game.mode = "score";
    }
    
    
    // Show the player the score
    game.score = function() {
      // ...what is the point of this method.
    }
    
    // ========================================= Images
    var img_cursor = loadImage(game.ctx, "images/cursor.png");
    
    
    // ========================================= LEVELS
    
    game.levels = [];
    game.current_level = 0;
    game.finalActions.push(function() { this.levels[this.current_level].draw(); });
    game.doNextLevel = function() {
      if (this.current_level < this.levels.length - 1) this.current_level += 1; 
    }
    
    function makeLevel(id) {
      var lvl = {
        id: id,
        text: [],
        score_text: [],
        draw: function() {
          var txt = this.text;
          if (game.mode == 'running' || game.mode == 'score') txt = txt.concat([round(timer.getTime(), 2).toString()]);
          if (game.mode == 'score') txt = txt.concat(this.score_text);
          rect(game.ctx, xy(0, 0), xy(game.size.x, level_text_height), colors.level_text);
          game.setFont(level_font);
          text(game.ctx, "Level " + this.id.toString(), xy(10, 20), "nw");
          game.setFont(default_font);
          text(game.ctx, txt, xy(20, 40), "nw");
          game.setFont(default_font);
          this.draw_extras();
        },
        draw_extras: function() {},
        objects: []
      };
      game.levels.push(lvl);
      return lvl;
    }
    function makeLevelObject(parent_level) {
      var obj = new GameObject(game);
      obj.level = parent_level;
      obj._tick = obj.tick;
      obj._draw = obj.draw;
      obj.tick = function() { if (game.levels[game.current_level].id != this.level.id) return; this._tick(); }
      obj.draw = function() { if (game.levels[game.current_level].id != this.level.id) return; this._draw(); }
      return obj;
    }
    
    // ----------------- Level 1 ------------------------
    var level1 = makeLevel(1);
    level1.text = [
      "Get to the other place in exactly ten seconds. Ten point oh, on the dot!",
      "Use the arrow keys to move. Press space when you're ready."
    ],
    level1.score_text = [" ... That could have been closer to 10. Press space to try again. Or, press enter to try the next level."];
    level1.draw_extras = function() {
      game.setFont(huge_font);
      text(game.ctx, ["This is, in fact,", "the easiest level!"], xy(240, 380), "nw", colors.blackish);
      game.setFont(default_font);      
    }
    
    // ----------------- Level 2 ------------------------
    var level2 = makeLevel(2);
    level2.text = [
      "Better hurry up! It will take longer to get through the swamp!"
    ],
    level2.score_text = [" ... That could have been closer to 10. Press space to try again. Or, press enter to try the next level."];
    level2.draw_extras = function() {
      game.setFont(huge_font);
      //text(game.ctx, ["This is, in fact,", "the easiest level!"], xy(240, 380), "nw", colors.blackish);
      game.setFont(default_font);      
    }
    
    // ========================================= The timer
    var timer = new GameObject(game);
    timer.t0 = null;
    timer.result = 0;
    timer.start = function() {
      this.t0 = now();
      this.result = 0;
    }
    timer.stop = function() {
      this.result = this.getTime();
      this.t0 = null;
    }
    timer.getTime = function() {
      if (game.mode != "running") return this.result;
      return getTimeSince(this.t0)/1000;
    }
    
    // ========================================= Mud.
    var swamp = makeLevelObject(level2);
    swamp.pos = end_pos.copy();
    swamp.size = 200;
    swamp.drawActions.push(function() {
      circle(this.ctx, this.pos, this.size, colors.swamp);
    });
    swamp.tickActions.push(function() {
      if (distance(ball.pos, this.pos) < this.size) ball.scaleVelocity(swamp_speed_reduction);
    });
    
    // ========================================= The start and end points
    var start_point = new GameObject(game);
    start_point.pos = start_pos;
    start_point.draw = function() {
      this.ctx.save();
      this.ctx.globalAlpha = 1;
      circle(this.ctx, this.pos, point_radius, colors.point);
      this.ctx.globalAlpha = 1;
      emptyCircle(this.ctx, this.pos, point_radius - 5, colors.point);
      emptyCircle(this.ctx, this.pos, point_radius - 10, colors.point);
      emptyCircle(this.ctx, this.pos, point_radius - 15, colors.point);
      this.ctx.restore();
    }
    
    var end_point = new GameObject(game);
    end_point.pos = end_pos;
    end_point.draw = start_point.draw;
    
    // ========================================= The ball
    var ball = new GameObject(game);
    ball.pos = start_point.pos.copy();
    actuate(ball);
    ball.tickActions.push(function() { game.mode == 'running'? this.unfreeze() : this.freeze(); });
    navigate(ball, keydirs_lrud, ball_speed);
    ball.freeze();
    ball.imprints = [];
    ball.draw = function() {
      circle(this.ctx, this.pos, ball_radius, colors.ball);
      if (game.mode != "design") {
        // Draw progress
        //text(this.ctx, Math.floor(timer.getTime()).toString(), yshift(this.pos, -2), 'centered', 'white');
        var a = 360 * timer.getTime() / 10;
        filledAngle(this.ctx, this.pos, ball_radius, -90, -90 + a, colors.ball2);
        
        // Draw imprints
        if (leave_ball_imprints && game.mode == 'running') circle(game.imprint_ctx, this.pos, ball_imprint_radius, colors.ball_faded);
        
        this.ctx.restore();
      }
    }
    ball.start = function() {
      this.velocity = ball_start_velocity.copy();
      this.unfreeze();
      if (leave_ball_imprints) setTimeout(function() { ball.imprint(); }, 1000);
    }
    ball.stop = function() {
      this.velocity = xy(0, 0);
      this.freeze();
    }
    ball.reset = function() {
      this.pos = start_point.pos.copy();
      this.imprints = [];
      this.freeze();
    }
    ball.imprint = function() {
      if (game.mode != "running") return;
      circle(game.imprint_ctx, this.pos, ball_radius, colors.ball_faded);
      setTimeout(function() { ball.imprint(); }, 1000);
    }
    // Movement effects
    ball.reverse = function() {
      this.velocity.neg();
    }
    ball.scaleVelocity = function(factor) {
      this.velocity_scale *= factor;
    }
    ball.velocity_scale = 1;
    ball._move = ball.move;
    ball.move = function(delta) { 
      //if (game.state.frame%50==0) console.log("old: " + delta + " | new: " +  scale(delta, this.velocity_scale));
      this._move(scale(delta, this.velocity_scale));
    }
    ball.preTickActions.push(function() { this.velocity_scale = 1; });
    
    // ========================================= Info line
    /*
    var info = new GameObject(game);
    info.pos = xy(game.size.x / 2, text_pad);
    info.pos2 = xy(game.size.x/ 2, game.size.y - text_pad);
    info.text = instructions_text;
    info.text2 = goal_text;
    info.font = {size: 20, type: 'Arial', italic: false};
    info.draw = function() {
      game.setFont(this.font);
      text(this.ctx, this.text, this.pos, "centered", colors.blackish);
      text(this.ctx, this.text2, this.pos2, "centered", colors.blackish);
      game.setFont(default_font);
    }
    */
    
  </script>
</html>